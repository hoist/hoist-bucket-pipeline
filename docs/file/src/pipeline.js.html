<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/pipeline.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  <a href="test.html" data-ice="testLink">Test</a>
  <a data-ice="repoURL" href="https://github.com/hoist/hoist-bucket-pipeline.git" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/pipeline.js~BucketPipeline.html">BucketPipeline</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://github.com/hoist/hoist-context/blob/feature/remove_cls/src/index.js">Context</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/pipeline.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">&apos;use strict&apos;;
import Errors from &apos;@hoist/errors&apos;;
import logger from &apos;@hoist/logger&apos;;
import {
  Bucket
}
from &apos;@hoist/model&apos;;

import {
  extend
}
from &apos;lodash&apos;;

/**
 * Pipeline class for interacting with Buckets
 */
class BucketPipeline {
  /**
   * create a new Pipeline
   */
  constructor() {
    this._logger = logger.child({
      cls: this.constructor.name
    });
  }
  _addHelper(context, key, meta) {
    return Promise.resolve().then(() =&gt; {
      var options = {
        application: context.application._id,
        environment: context.environment
      };
      if (key) {
        options.key = key;
      }
      if (meta) {
        options.meta = meta;
      } else {
        options.meta = {};
      }
      var newBucket = this._createBucket(options);
      return newBucket.saveAsync().then((bucket) =&gt; {
        return bucket.toObject();
      });
    });
  }
  _createBucket(options) {
    return new Bucket(options);
  }
  _saveMetaHelper(bucket, meta) {
    if (bucket) {
      if (bucket.meta) {
        bucket.meta = extend(bucket.meta, meta);
      } else {
        bucket.meta = meta;
      }
      bucket.markModified(&apos;meta&apos;);
      return bucket.saveAsync().then((results) =&gt; {
        return results[0].meta;
      });
    }
    throw new Errors.bucket.NotFoundError();
  }

  /**
   * add a new bucket and set the meta data
   * @param {Context} context - the current context
   * @param {String} key - the unique key for the bucket
   * @param {Object} [meta] - any mata data to save
   * @returns {Promise&lt;Object&gt;} - the Bucket in object form
   */
  add(context, key, meta) {
    return Promise.resolve()
      .then(() =&gt; {
        if (!meta &amp;&amp; typeof key === &apos;object&apos;) {
          meta = key;
          key = null;
        }
        if (key) {
          this._logger.info(&apos;resolving context&apos;);

          this._logger.info({
            context: context
          }, &apos;looking up bucket&apos;);
          return Bucket.findOneAsync({
              key: key,
              environment: context.environment,
              application: context.application._id
            })
            .then((bucket) =&gt; {
              if (bucket) {
                throw new Errors.bucket.InvalidError(&apos;A bucket with key &quot;&apos; + key + &apos;&quot; already exists&apos;);
              }
              return this._addHelper(context, key, meta);
            });
        }
        return this._addHelper(context, key, meta);
      });
  }

  /**
   * load the bucket specified from the database or create it
   * and set it as the current bucket
   * @param {Context} context - the current context
   * @param {String} key - the unique key for the bucket
   * @param {Boolean} [create=false] - should we create the bucket?
   * @returns {Promise&lt;Object&gt;} - the Bucket in object form
   */
  set(context, key, create) {
    var self = this;
    this._logger.info(&apos;resolving context&apos;);
    return Promise.resolve()
      .then(() =&gt; {
        this._logger.info({
          context: context
        }, &apos;looking up bucket&apos;);
        return Bucket.findOneAsync({
            key: key,
            environment: context.environment,
            application: context.application._id
          })
          .then((bucket) =&gt; {
            this._logger.info({
              bucket: bucket
            }, &apos;bucket lookup complete&apos;);
            if (bucket) {
              return (context.bucket = bucket.toObject());
            }
            if (create) {
              return self.add(key).then((addedBucket) =&gt; {
                if (addedBucket) {
                  //add returns an object so don&apos;t call to object here
                  return (context.bucket = addedBucket);
                }
                throw new Errors.bucket.SaveError();
              });
            }
            throw new Errors.bucket.NotFoundError();
          });
      });
  }

  /**
   * get a new bucket from the database
   * @param {Context} context - the current context
   * @param {String} key - the unique key for the bucket
   * @returns {Promise&lt;Object&gt;} - the Bucket in object form
   */
  get(context, key) {
    this._logger.info(&apos;getting bucket&apos;);
    this._logger.info(&apos;retrieving context&apos;);
    return Promise.resolve()
      .then(() =&gt; {
        if (key) {
          this._logger.info(&apos;loading bucket by key&apos;);
          return Bucket.findOneAsync({
              key: key,
              environment: context.environment,
              application: context.application._id
            })
            .then((bucket) =&gt; {
              if (bucket) {
                return bucket.toObject();
              }
              throw new Errors.bucket.NotFoundError();
            });
        }
        if (context.bucket) {
          this._logger.info(&apos;loading from context&apos;);
          return Bucket.findOneAsync({
            key: context.bucket.key,
            environment: context.environment,
            application: context.application._id
          }).then((bucket) =&gt; {
            if (bucket) {
              this._logger.info(&apos;retrieved bucket&apos;);
              return bucket.toObject();
            }
            this._logger.info(&apos;no bucket found&apos;);
            throw new Errors.bucket.NotFoundError();
          });
        }
        return null;
      });
  }

  /**
   * remove bucket from the database
   * @param {Context} context - the current context
   * @param {String} key - the unique key for the bucket
   * @returns {Promise} - the Promise to have deleted the bucket
   */
  remove(context, key) {
    this._logger.info(&apos;remove bucket&apos;);
    this._logger.info(&apos;getting context&apos;);
    return Promise.resolve()
      .then(() =&gt; {
        if (key) {
          this._logger.info(&apos;removing bucket by key&apos;);
          return Bucket.removeAsync({
            key: key,
            environment: context.environment,
            application: context.application._id
          }).then(() =&gt; {

            if (context.bucket &amp;&amp; context.bucket.key === key) {
              this._logger.info(&apos;removing bucket from context&apos;);
              context.bucket = null;
            }
          });
        }
        if (context.bucket) {
          this._logger.info(&apos;removing bucket by context&apos;);
          return Bucket.removeAsync({
            key: context.bucket.key,
            environment: context.environment,
            application: context.application._id
          }).then(() =&gt; {
            this._logger.info(&apos;removing bucket from context&apos;);
            context.bucket = null;
          });
        }
        return null;

      });
  }

  /**
   * get all application buckets from the database
   * @param {Context} context - the current context
   * @returns {Promise&lt;Array&lt;Object&gt;&gt;} - an Array of Buckets in object form
   */
  getAll(context) {
    this._logger.info(&apos;getting all buckets&apos;);
    return Promise.resolve()
      .then(() =&gt; {
        this._logger.info(&apos;loaded context&apos;);
        return Bucket.findAsync({
          environment: context.environment,
          application: context.application._id
        }).then((buckets) =&gt; {
          this._logger.info({
            bucketCount: buckets.length
          }, &apos;returning buckets&apos;);
          return buckets.map((bucket) =&gt; {

            return bucket.toObject();
          });
        });
      });
  }

  /**
   * run a function over every bucket in the organisation
   * @param {Context} context - the current context
   * @param {function(Bucket: bucket)} fn - the function to run
   * @returns {Promise} - promise to have run the function over each bucket
   */
  each(context, fn) {
    this._logger.info(&apos;calling each&apos;);
    return this.getAll(context).then((buckets) =&gt; {
      this._logger.info(&apos;running function against each bucket&apos;);
      return Promise.all(buckets.map((bucket) =&gt; {
        this._logger.info({
          bucketId: bucket._id
        }, &apos;running function against a bucket&apos;);
        return Promise.resolve(fn(bucket));
      }));
    });
  }

  /**
   * sets and replaces meta data against a bucket
   * @param {Context} context - the current context
   * @param {Object} meta - the mata data to save
   * @param {String} [key] - the unique key for the bucket, if not set use the current context bucket
   * @returns {Promise&lt;Object&gt;} - the Bucket in object form
   */
  saveMeta(context, meta, key) {
    this._logger.info(&apos;saving meta data&apos;);
    this._logger.info(&apos;getting context&apos;);
    return Promise.resolve()
      .then(() =&gt; {
        this._logger.info(&apos;retrieved context&apos;);
        if (key) {
          this._logger.info(&apos;finding bucket by key&apos;);
          return Bucket.findOneAsync({
              key: key,
              environment: context.environment,
              application: context.application._id
            })
            .then((bucket) =&gt; {
              this._logger.info(&apos;saving meta data to bucket&apos;);
              return this._saveMetaHelper(bucket, meta);
            });
        }
        if (context.bucket) {
          this._logger.info(&apos;finding bucket by context&apos;);
          return Bucket.findOneAsync({
            key: context.bucket.key,
            environment: context.environment,
            application: context.application._id
          }).then((bucket) =&gt; {
            this._logger.info(&apos;saving meta data to bucket&apos;);
            return this._saveMetaHelper(bucket, meta);
          });
        }
        this._logger.info(&apos;no bucket found&apos;);
        throw new Errors.bucket.NotFoundError();
      });
  }
}

export default BucketPipeline;

/**
 * @external {Context} https://github.com/hoist/hoist-context/blob/feature/remove_cls/src/index.js
 */
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.4)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
